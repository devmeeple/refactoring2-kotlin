# 2. 리팩터링 원칙

**목차**

- [2.1 리팩터링 정의](#21-리팩터링-정의)
- [2.2 두 개의 모자](#22-두-개의-모자)
- [2.3 리팩터링하는 이유](#23-리팩터링하는-이유)
- [2.4 언제 리팩터링해야 할까?](#24-언제-리팩터링해야-할까)
- [2.5 리팩터링 시 고려할 문제](#25-리팩터링-시-고려할-문제)
- [2.6 리팩터링, 아키텍처, 애그니(YAGNI)](#26-리팩터링-아키텍처-애그니yagni)
- 2.7 리팩터링과 소프트웨어 개발 프로세스
- 2.8 리팩터링과 성능
- 2.9 리팩터링의 유래
- 2.10 리팩터링 자동화
- 2.11 더 알고 싶다면

## 2.1 리팩터링 정의

- 리팩터링이란 무엇일까? 보편적으로 명사와 동사를 혼용해서 사용한다. 하지만 저자는 명확한 용어 구분을 제안한다.
- 명사 vs. 동사
    - 명사: 동작은 그대로 두고, 이해하기 쉽도록 다듬는 방법
    - 동사: 동작은 그대로 두고, 리팩터링 방법을 적용해 다듬다.
- **리팩터링의 궁극적인 목표는 코드를 이해하여 수정하고 쉽게 만들기다.**

## 2.2 두 개의 모자

> 의도를 명확하게 하자.

- '기능 추가'와 '리팩터링'을 명확히 구분하고 작업하자.
    - 자주 바꿔 쓰자.


## 2.3 리팩터링하는 이유

> No Silver Bullet - Essence and Accident in Software Engineering.

- 리팩터링 또한 소프트웨어 세계의 전반적인 문제를 해결하는 만병통치약이 아니다. 하지만 '건강한 상태 유지'에 적합한 약은 분명하다.

**리팩터링하면 소프트웨어 설계가 좋아진다**

- 리팩터링 하지 않는 코드는 고인 물과 같다. 고인 물이 될 것인가, 흐르는 물이 될 것인가?
- 리팩터링은 복잡한 문제를 해결하기 위한 설계를 지탱한다.
- 작성한 코드 양이 줄어드는 것은 수정할 코드 양도 줄어듬을 의미한다.

**리팩터링하면 소프트웨어를 이해하기 쉬워진다**

- 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다.
- 코드를 컴파일하는 데 시간이 살짝 더 걸린다고 누가 뭐라 하겠는가? 하지만 다른 프로그래머가 내 코드를 제대로 이해했다면 한 시간에 끝낼 수정을 일주일이나 걸린다면 사정이 달라진다.
- 코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다. 잘 작동하지만 이상적인 구조는 아닌 코드가 있다면, 잠깐 시간을 내서 리팩터링해보자. 그러면 코드의 목적이 더 잘 드러나게, 다시 말해 내 의도를 더 명확하게 전달하도록 개선할 수 있다.
- 글을 퇴고하는 이유는 의도를 명확하게 전달하기 위함이다. 리팩터링 또한 그렇다.

**리팩터링하면 버그를 쉽게 찾을 수 있다**

> I'm not a great programmer; I'm just a good programmer with great habits.<br>
> <출처: Kent Beck>

- 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.
- 프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.
- 리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.

**리팩터링하면 프로그래밍 속도를 높일 수 있다**

- **설계는 고정되지 않는다. 유연하게 변화한다. 리팩터링은 지속해서 설계를 개선하는 방법이다.**
- 리팩터링하면 코드 개발 속도를 높일 수 있다.
- 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 
- 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.
- 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다. 
- 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.
- 지구력 가설(Design Stamina Hypothesis), 내부 설계에 심혈을 기울이면 소프트웨어 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.
- 처음부터 좋은 설계를 마련하기란 매우 어렵다. 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.

<참고 자료>

- [Martin Fowler 'Design Stamina Hypothesis'](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)

## 2.4 언제 리팩터링해야 할까?

> 3의 법칙 <출처: Don Roberts>
> 
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

**준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**

- **말이 아닌, 변화에 유연하게 대응할 수 있는 '상황'을 만들자.**
- 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸며 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.
- 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다. 또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다.

<참고 자료>

- [Martin Fowler 'An example of preparatory refactoring'](https://martinfowler.com/articles/preparatory-refactoring-example.html)

**이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**

- **리팩터링은 끝없는 탐구다. 시도해야 기회를 발견한다.**
- 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다.
- 워드 커닝햄(Ward Cunningham)이 말하길, 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다.
- 이해를 위한 리팩터링(Comprehension Refactoring)
- 랄프 존슨(Ralph Johnson)은 이런 초기 단계의 리팩터링을 밖을 잘 내다보기 위한 창문 닦기에 비유한다.
- 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

**쓰레기 줍기 리팩터링**

> 쓰레기를 줍는 건 다른 사람이 무심코 버린 행운을 줍는 겁니다.<br>
> <출처: 오타니 쇼헤이(大谷翔平)>

- 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.
- 이해를 위한 리팩터링의 변형, 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)
- 물론 수정하려면 몇 시간이나 걸리고 당장은 더 급한 일이 있을 수 있다. 그렇더라도 조금이나마 개선해두는 것이 좋다. 캠핑 규칙이 제안하듯, 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.
- 리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다.

**계획된 리팩터링과 수시로 하는 리팩터링**

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

- **마지막 리팩터링이 언제지? 의식하지 못할 정도로 녹아들어라.**
- 글쓰기의 퇴고와 리팩터링은 유사하다.
- 기능을 추가할 때든 버그를 잡을 때든, 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에도 도움을 준다.
- 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.

> for each desired change, make the change easy(warning:this may be hard), them make the easy change<br>
> [<출처: Kent Beck>]((https://x.com/KentBeck/status/250733358307500032))

- 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일수 있다.
- 소프트웨어 개발은 끝이 없다. 기능을 필요할 때마다 반영하기 위해 수정한다.
- 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.
- 기능 추가 커밋과 리팩터링 커밋 분리 견해.

**오래 걸리는 리팩터링**

- 한 번에 모든 것을 변화시키기보단, 점진적 개선을 지향한다.

**코드 리뷰에 리팩터링 활용하기**

- **팀 단위로 접근하는 신사적인 방법, 서로가 서로에게 기여하다.**
- **리팩터링은 문학이다. 상상을 넘어 체험하게 만들어 준다.**
- 코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다. 경험이 더 많은 개발자의 노하루를 더 적은 개발자에게 전수할 수 있다.
- 깔끔한 코드를 작성하는 데에도 굉장히 중요하다.
- 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움된다. 머리로만 상상하는 게 아니라 눈으로 직접 확인하는 것이다.
- 짝 프로그래밍(pair programming)

**관리자에게는 뭐라고 말해야 할까?**

- **당신은 프로인가요? 스스로 질문을 던진다.**
- 일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 그리고 구체적인 방법은 개발자가 판단해야 한다.
- 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.

**리팩터링하지 말아야 할 때**

> <출처: 원피스, 골디로저>

- **확장판, 미지의 세계에 대해 선배가 조언해주는 인상을 받았다.**
- **때가 됐을 때 자연스레 깨닫길 바란다. <출처: 폴인 '윤종신>**
- 리팩터링하면 안 되는 상황도 있다.
- 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.
- 리팩터링할지 새로 작성할지를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야 한다.

## 2.5 리팩터링 시 고려할 문제

- 무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다.
- 리팩터링에 딸려 오는 문제도 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 한다.

**새 기능 개발 속도 저하**

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

- **건강한 코드베이스에서 발생하는 생산성 차이를 경험하라.**
- 리팩터링은 경제적인 관점에서 필요하다. 아름다움 추구가 아니다.
- 새로운 기능을 추가하고 변화에 대응하기 위함이다.

**코드 소유권**

- **코드를 오픈 소스처럼 공동 소유로 정의하는 편이 리팩터링에 유리하지 않을까?**

**브랜치**

- **브랜치 사용 갑론을박**

**테스팅**

- **리팩터링에서 발생하는 오류를 빠르게 발견하기 위해서는 짧은 주기에서 테스트가 필수다.**
- 자동 리팩터링만 사용하자! 사실과 오해

**레거시 코드**

**데이터 베이스**


## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

- **리팩터링은 예측이 아닌 현재에 충실하는 방법이다. 요구사항을 더욱 이해했을 때 개선한다.**
- 리팩터링은 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꿔놓았다.
- 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변회에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다.
- 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가한다.
