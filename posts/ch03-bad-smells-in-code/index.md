# 3. 코드에서 나는 악취(Bad Smells in Code)

- 리팩터링, 언제 시작하고 언제 그만두면 좋을까? 자신의 직관을 믿어라.
- 리팩터링을 이야기 할 때 냄새(smell)를 자주 사용한다. 켄트백의 일화에서 출발했다.

## 3.1 기이한 이름(Mysterious Name)

- 코드는 명료해야 한다. 명료함을 표현하는 가장 간단한 방법은 '이름'이다.
- 이름 작성은 물론 어렵다. 하지만 그럼에도 포기할 수 만큼 중요하다.
- **방법**
    - 함수 선언 바꾸기(6.5)
    - 변수 이름 바꾸기(6.7)
    - 필드 이름 바꾸기(9.2)

## 3.2 중복 코드(Duplicated Code)

- 중복을 하나로 통합하면 더 나은 프로그램에 다가갈 수 있다.
- **방법**
    - 함수 추출하기(6.1)
    - 문장 슬라이드하기(6.2): 비슷한 부분 한곳에 모으기
    - 메서드 올리기(12.1)

## 3.3 긴 함수(Long Function)

- 명료한 문장에서 리듬감을 느끼고 이해하기 쉽듯이, 코드도 마찬가지다.
- ? 간접 호출(indirection), 서브루틴 호출
- 함수 이름은 동작방식이 아닌 '의도'를 전달하기 위해 존재한다. 무엇을 하고 싶은가?
- **방법**
  - 함수 추출하기(6.1)
  - 임시 변수를 질의 함수로 바꾸기(7.4)
  - 매개변수 객체 만들기(6.8)
  - 객체 통째로 넘기기(11.4)
  - 함수를 명령으로 바꾸기(11.9)
  - 조건문 분해하기(10.1)
  - 조건부 로직을 다형성으로 바꾸기(10.4)
  - 반복문 쪼개기(8.7)

## 3.4 긴 매개변수 목록(Long Parameter List)

- ? 부분 적용 함수(partially appied function)
- **방법**
  - 매개변수를 질의 함수로 바꾸기(11.5)
  - 객체 통째로 넘기기(11.4)
  - 매개변수 객체 만들기(6.8)
  - 플래그 인수 제거하기(11.3)
  - 여러 함수를 클래스로 묶기(6.9)

## 3.5 전역 데이터(Global Data)

> 무엇이든 많이 복용하면 독이 될 수 있다.
> -파라겔수스(Paracelsus)

- **변수 캡슐화하기(6.6)**: 데이터를 함수로 감싸다. 오염 확률 규제.
    - ? 접근 범위를 줄이다. 접근자 함수는 클래스나 모듈에 집어넣고 안에서만 사용하는 방법을 권장한다.
- 행방불명, 수취인불명; 전역 데이터는 가장 고약한 악취다. 누가, 어떤 의도로 값을 변경했는지 조사하기 어렵다.
    - `클래스 변수`와 `싱글톤(Singleton)`에서도 같은 문제가 발생한다.
- ? 심지어 전역 데이터가 `가변(mutable)`이라면 타의 추종을 불허한다.
- **가능한, 전역 데이터를 최소화하자.  소프트웨어의 진화를 위하여.**

## 3.6 가변 데이터(Mutable Data)

> 변수의 유효 범위는 줄이고, 신체 가동범위는 늘려라!

- **변수 캡슐화하기(6.6)**: 함수를 거쳐야만 데이터에 접근한다.
- **변수 쪼개기(9.1)**: 용도별로 분류하다. 데이터 갱신에서 발생하는 위험 예방.
- **데이터 갱신에서 발생하는 위험 예방하기**
    - 문장 슬라이드하기(8.6), 함수 추출하기(6.1)
- **API 부작용 줄이기**
    - 질의 함수와 변경 함수 분리하기(11.1)
- **변수 유효범위 줄이기**
    - 세터 제거하기(11.7)
- ? 함수형 프로그래밍에서는 데이터의 불변을 강조할까, 불변은 왜 중요할까
    - ? 위험을 줄이는 방법, 어떤 위험이 당신을 위협하는가.
- 파생 변수를 질의 함수로 바꾸기(9.3)
- 여러 함수를 클래스로 묶기(6.9)
- 여러 함수를 변환 함수로 묶기(6.10)
- 참조를 값으로 바꾸기(9.4)

## 3.7 뒤엉킨 변경(Divergent Change)

- 소프트웨어는 '소프트(Soft)'해야 마땅하지 않은가? 변경하기 쉬운 구조를 지향하는 가장 간단한 이유
- **? 단일 책임 원칙(SRP, Single Responsibility Principle)**
    - 단일 책임 원칙을 지키지 않았을 때 모듈을 변경하는 이유가 여러 방식으로 파생된다.
- **방법**
    - 단계 쪼개기(6.11)
    - 함수 옮기기(8.1)
    - 함수 추출하기(6.1)

## 3.8 산탄총 수술(Shotgun Surgery)

> 흩날려라 천본앵
> -블리치, 쿠치기 바쿠야

- 코드가 천본앵 당했다. 흩날려라 코드.
- vs. 뒤엉킨 변경(3.7): 비슷한데 대비된다?
- **방법**
    - 함수 옮기기(8.1): 모듈에 묶기
    - 필드 옮기기(8.2): 모듈에 묶기
    - 여러 함수를 클래스로 묶기(8.2): 비슷한 데이터 다루기
    - 여러 함수를 변환 함수로 묶기(6.10): 구조 변화, 보강(enrich; 충치)
    - 단계 쪼개기(6.11)
    - 함수 인라인하기(6.2)
    - 클래스 인라인하기(6.7)

## 3.9 기능 편애(Feature Envy)

> 소속된 모듈보다 다른 모듈과 상호작용이 과할 때 풍기는 냄새

- ? 모듈화, 영역 안에서 이뤄지는 상호작용은 늘리고 사이에서 이뤄지는 상호작용은 최소로 줄이다.
- 소속된 모듈보다 다른 모듈과 상호작용이 과할 때 풍기는 냄새
- **방법: 관련있는 코드 모으기**
    - 함수 옮기기(8.1): 근처로 이동하기
    - 함수 추출하기(6.1): 독립된 함수 선언 후 이동하기; 조각으로 나누고 적합한 장소로 옮기기
- **? 참고: 뒤엉킨 냄새 모두 안녕!**
    - 전략 패턴(Strategy Pattern)
    - 방문자 패턴(Visitor Pattern)
    - 자기 위임(Self-Delegation)

## 3.10 데이터 뭉치(Data Clumps)

- 데이터는 아가야. 보살펴 줘!
- ? 데이터 뭉치 판별법
- ? 클래스를 사용하면 좋은 향기를 흩뿌릴 기회를 얻는다.
    - 클래스를 사용하지 않는 개발자는 어떻게 향기를 뿌리는가.
- **방법**
    - 클래스 추출하기(7.5): 필드 묶기
    - 매개변수 객체 만들기(6.8), 객체 통째로 넘기기(11.4): 시그니처 변경하기

## 3.11 기본형 집착(Primitive Obsession)

- ? 문자열화된 변수(stringly typed)
- **방법**
    - 기본형을 객체로 바꾸기(7.3): 구석기에서 온돌로; 아그리콜라
    - 타입 코드를 서브클래스로 바꾸기(12.6)
    - 조건부 로직을 다형성으로 바꾸기(10.4)
    - 클래스 추출하기(7.5)
    - 매개변수 객체만들기(6.8)
